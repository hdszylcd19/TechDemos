package com.oneday.demo.test_int_range;

/**
 * Desc: 测试int值计算越界问题
 *
 * @author JiLin
 * @version 1.0
 * @since 2021/2/2 13:29
 */
class TestIntRange {
    public static void main(String[] args) {
        // int类型的最小值为-2147483648
        int a = -2147483600;
        int b = 48;
        //此时f结果为int类型的最小值，使用int类型接收刚刚好
        int f = a - b;
        System.out.println("a-b(int类型最小值) = " + f);

        int c = 50;
        f = a - c;
        System.out.println("a-c(数据溢出) = " + f);
        //本来结果应该为-2147483650才对，但是因为超过了int类型的最小边界，使用int类型接收的话会发生越界问题，结果变成了2147483646
        /*
         * -2147483600 - 50 = (-2147483600补码) + (-50补码)
         * 1111 1111 1111 1111 1111 1111 1101 0000  -2147483600原码
         * 1000 0000 0000 0000 0000 0000 0010 1111  -2147483600反码
         * 1000 0000 0000 0000 0000 0000 0011 0000  -2147483600补码
         *
         * 1000 0000 0000 0000 0000 0000 0011 0010  -50原码
         * 1111 1111 1111 1111 1111 1111 1100 1101  -50反码
         * 1111 1111 1111 1111 1111 1111 1100 1110  -50补码
         *
         * 1000 0000 0000 0000 0000 0000 0011 0000  -2147483600补码
         *+1111 1111 1111 1111 1111 1111 1100 1110  -50补码
         * 0111 1111 1111 1111 1111 1111 1111 1110  结果补码
         *
         * 我们发现因为符号位参与计算，导致符号位溢出，变为了0，也就是变成了正数；正数的原、反、补码一致，所以最终的结果变为了2147483646
         * 要想确保结果计算正确，我们需要使用long类型来接收，也就是更大的容器来接收，确保符号位不溢出。
         * */

        long result = (long) a - c;
        System.out.println("a-c(正确结果) = " + result);
    }
}
